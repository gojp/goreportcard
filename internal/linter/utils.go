package linter

import (
	"bufio"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"
	"syscall"

	"github.com/gojp/goreportcard/internal/model"

	"github.com/pkg/errors"
	"github.com/yeqown/log"
)

var (
	skipDirs       = []string{"Godeps", "vendor", "third_party", "testdata"}
	skipSuffixes   = []string{".pb.go", ".pb.gw.go", ".generated.go", "bindata.go", "_string.go"}
	skipFirstLines = []string{"code generated", "generated", "autogenerated", "@generated", "code autogenerated", "auto-generated"}
)

func addSkipDirs(params []string) []string {
	for _, dir := range skipDirs {
		params = append(params, fmt.Sprintf("--skip-dirs=%s", dir))
	}
	return params
}

// GoFiles returns a slice of Go filenames
// in a given directory.
// TODO: To optimize the logic of file walk
func visitGoFiles(dir string) (filenames, skipped []string, err error) {
	visit := func(fp string, fi os.FileInfo, err error) error {
		// log.Debugf("visit dir=%s, fp=%s", fi.Name(), fp)

		for _, skip := range skipDirs {
			if strings.Contains(fp, fmt.Sprintf("/%s/", skip)) {
				return nil
			}
		}
		if err != nil {
			log.Errorf("GoFiles failed: err=%v", err) // can't walk here,
			return nil                                // but continue walking elsewhere
		}
		if fi.IsDir() {
			return nil // not a file.  ignore.
		}
		fiName := fi.Name()
		for _, skip := range skipSuffixes {
			if strings.HasSuffix(fiName, skip) {
				skipped = append(skipped, fp)
				return nil
			}
		}
		ext := filepath.Ext(fiName)
		if ext != ".go" {
			return nil
		}

		if autoGenerated(fp) {
			skipped = append(skipped, fp)
			return nil
		}

		filenames = append(filenames, fp)

		return nil
	}

	err = filepath.Walk(dir, visit)

	return filenames, skipped, err
}

// RenameFiles renames the provided filenames to have a ".grc.bk" extension,
// so they will not be considered in future checks.
func RenameFiles(names []string) (err error) {
	for i := range names {
		tmpErr := os.Rename(names[i], names[i]+".grc.bk")
		if tmpErr != nil {
			// save this error, but still continue with other files
			err = tmpErr
		}
	}

	return err
}

// RevertFiles removes the ".grc.bk" extension from files
func RevertFiles(names []string) (err error) {
	for i := range names {
		tmpErr := os.Rename(names[i]+".grc.bk", names[i])
		if tmpErr != nil {
			// save this error, but still continue with other files
			err = tmpErr
		}
	}

	return err
}

// lineCount returns the number of lines in a given file
func lineCount(filepath string) (int, error) {
	out, err := exec.Command("wc", "-l", filepath).Output()
	if err != nil {
		return 0, err
	}
	// wc output is like: 999 filename.go
	count, err := strconv.Atoi(strings.Split(strings.TrimSpace(string(out)), " ")[0])
	if err != nil {
		return 0, fmt.Errorf("could not count lines: %v", err)
	}

	return count, nil
}

// determine whether the Go file was auto-generated
// FIXME: fp is not right path to file
func autoGenerated(fp string) bool {
	file, err := os.Open(fp)
	if err != nil {
		fp, _ = filepath.Abs(fp)
		log.Errorf("autoGenerated failed to open file err=%v, fp=%s", err, fp)
		return false
	}
	defer file.Close()

	// read first line of file and determine if it might
	// be auto-generated
	scanner := bufio.NewScanner(file)
	scanner.Scan()
	line := strings.ToLower(scanner.Text())
	commentStyles := []string{"// ", "//", "/* ", "/*"}
	for _, skip := range skipFirstLines {
		for i := range commentStyles {
			if strings.HasPrefix(line, commentStyles[i]) && strings.HasPrefix(line[len(commentStyles[i]):], skip) {
				return true
			}
		}
	}
	return false
}

// borrowed from github.com/client9/gosupplychain
// MIT LICENSE: https://github.com/client9/gosupplychain/blob/master/LICENSE
func goPkgInToGitHub(name string) string {
	dir := ""
	var pkgversion string
	var user string
	parts := strings.Split(name, "/")
	if len(parts) < 2 {
		return ""
	}
	if parts[0] != "gopkg.in" {
		return ""
	}

	idx := strings.Index(parts[1], ".")
	if idx != -1 {
		pkgversion = parts[1]
		if len(parts) > 2 {
			dir = "/" + strings.Join(parts[2:], "/")
		}
	} else {
		user = parts[1]
		pkgversion = parts[2]
		if len(parts) > 3 {
			dir = "/" + strings.Join(parts[3:], "/")
		}
	}
	idx = strings.Index(pkgversion, ".")
	if idx == -1 {
		return ""
	}
	pkg := pkgversion[:idx]
	if user == "" {
		user = "go-" + pkg
	}
	version := pkgversion[idx+1:]
	if version == "v0" {
		version = "master"
	}

	return "https://github.com/" + user + "/" + pkg + "/blob/" + version + dir
}

// FIXME: with plugin options
func fileURL(dir, filename string) string {
	var fileURL string
	base := strings.TrimPrefix(dir, "_repos/src/")
	switch {
	case strings.HasPrefix(base, "golang.org/x/"):
		var pkg string
		if len(strings.Split(base, "/")) >= 3 {
			pkg = strings.Split(base, "/")[2]
		}
		return fmt.Sprintf("https://github.com/golang/%s/blob/master%s", pkg, strings.TrimPrefix(filename, "/"+base))
	case strings.HasPrefix(base, "github.com/"):
		if len(strings.Split(base, "/")) == 4 {
			base = strings.Join(strings.Split(base, "/")[0:3], "/")
		}
		return fmt.Sprintf("https://%s/blob/master%s", base, strings.TrimPrefix(filename, "/"+base))
	case strings.HasPrefix(base, "gopkg.in/"):
		log.Info(goPkgInToGitHub(base))
		log.Info(strings.TrimPrefix(filename, "/"+base))
		return goPkgInToGitHub(base) + strings.TrimPrefix(filename, "/"+base)
	}

	return fileURL
}

// FIXME: with plugin options
func makeFilename(fn string) string {
	sp := strings.Split(fn, "/")
	switch {
	case strings.HasPrefix(fn, "/github.com"):
		if len(sp) > 3 {
			return strings.Join(sp[3:], "/")
		}
	case strings.HasPrefix(fn, "/golang.org/x"):
		if len(sp) > 3 {
			return strings.Join(sp[3:], "/")
		}
	case strings.HasPrefix(fn, "/gopkg.in"):
		if len(sp) > 3 {
			return strings.Join(sp[3:], "/")
		}
	}

	return fn
}

// 获取文件的错误代码 概览
// TODO:
func getFileSummaryMap(out *bufio.Scanner, dir string) (map[string]model.FileSummary, error) {
	fsMap := make(map[string]model.FileSummary)
outer:
	for out.Scan() {
		filename := strings.Split(out.Text(), ":")[0]
		if !strings.HasSuffix(filename, ".go") {
			// true: 如果不是合法的文件名
			continue
		}

		for _, skip := range skipSuffixes {
			if strings.HasSuffix(filename, skip) {
				continue outer
			}
		}
		if autoGenerated(filepath.Join(dir, filename)) {
			continue outer
		}

		filename = strings.TrimPrefix(filename, "_repos/src")
		fu := fileURL(dir, filename)
		fs := fsMap[filename]
		if fs.Filename == "" {
			fs.Filename = makeFilename(filename)
			fs.FileURL = fu
		}
		err := fs.AddError(out.Text())
		if err != nil {
			return nil, err
		}
		fsMap[filename] = fs
	}
	return fsMap, nil
}

// GoTool runs a given go command (for example gofmt, go tool vet)
// on a directory
// TODO:
func GoTool(dir string, filenames, command []string) (float64, []model.FileSummary, error) {
	// started := time.Now()
	// temporary disabling of misspell as it's the slowest
	// command right now
	if strings.Contains(command[len(command)-1], "misspell") && len(filenames) > 1000 {
		log.Info("disabling misspell on large repo...")
		return 1, []model.FileSummary{}, nil
	}

	params := command[1:]
	params = addSkipDirs(params)
	params = append(params, "./...")

	cmd := exec.Command(command[0], params...)
	cmd.Dir, _ = filepath.Abs(dir)

	log.Debugf("GoTools got command=[%s] in Dir=[%s]", cmd.String(), cmd.Dir)

	// create an pipe to recv stdout message
	rc, err := cmd.StdoutPipe()
	if err != nil {
		return 0, []model.FileSummary{}, errors.Wrap(err, "GoTool.cmd.StdoutPipe")
	}
	if err = cmd.Start(); err != nil {
		return 0, []model.FileSummary{}, errors.Wrap(err, "GoTool.cmd.Start")
	}

	var (
		scanner = bufio.NewScanner(rc)

		// the same file can appear multiple times out of order
		// in the output, so we can't go line by line, have to store
		// a map of filename to FileSummary
		failed = []model.FileSummary{}
	)

	// log.Infof("getFileSummaryMap with dir=%s\n", dir)
	fsMap, err := getFileSummaryMap(scanner, dir)
	if err != nil {
		return 0, []model.FileSummary{}, errors.Wrap(err, "GoTool.getFileSummaryMap")
	}
	if err := scanner.Err(); err != nil {
		return 0, []model.FileSummary{}, errors.Wrap(err, "GoTool.scanner.Err")
	}

	for _, v := range fsMap {
		failed = append(failed, v)
	}

	err = cmd.Wait()
	if exitErr, ok := err.(*exec.ExitError); ok {
		// The program has exited with an exit code != 0
		if status, ok := exitErr.Sys().(syscall.WaitStatus); ok {
			// some commands exit 1 when files fail to pass (for example go vet)
			if status.ExitStatus() != 1 {
				return 0, failed, errors.Wrap(err, "GoTool.Wait")
			}
		}
	}

	if len(filenames) == 1 {
		lc, err := lineCount(filenames[0])
		if err != nil {
			return 0, failed, err
		}

		var errors int
		if len(failed) != 0 {
			errors = len(failed[0].Errors)
		}

		return float64(lc-errors) / float64(lc), failed, nil
	}

	// log.Info("END: ", command, time.Now().Sub(started))
	return float64(len(filenames)-len(failed)) / float64(len(filenames)), failed, nil
}

// GoFmtNative runs gofmt via golang's stdlib format pkg
// func GoFmtNative(dir string, filenames []string) (float64, []model.FileSummary, error) {
// 	fsChan := make(chan FileSummary)
// 	errChan := make(chan error)
// 	stopChan := make(chan bool)
// 	go func(stopChan chan bool) {
// 		for _, f := range filenames {
// 			for _, skip := range skipSuffixes {
// 				if strings.HasSuffix(f, skip) {
// 					continue
// 				}
// 			}

// 			if autoGenerated(f) {
// 				continue
// 			}

// 			go func(c chan FileSummary, errChan chan error, f string) {
// 				b, err := ioutil.ReadFile(f)
// 				if err != nil {
// 					errChan <- err
// 				}
// 				g, err := format.Source(b)
// 				if err != nil {
// 					errChan <- err
// 				}
// 				if !bytes.Equal(b, g) {
// 					filename := strings.TrimPrefix(f, "_repos/src")
// 					fs := FileSummary{}
// 					fs.Filename = makeFilename(filename)
// 					fu := fileURL(dir, strings.TrimPrefix(f, "_repos/src"))
// 					fs.FileURL = fu
// 					fs.Errors = append(fs.Errors, Error{1, "file is not gofmted"})

// 					fsChan <- fs
// 				}
// 			}(fsChan, errChan, f)
// 		}
// 		stopChan <- true
// 	}(stopChan)

// 	var (
// 		failed = []model.FileSummary{}
// 		f      FileSummary
// 		err    error
// 	)
// 	for {
// 		select {
// 		case fsChan <- f:
// 			failed = append(failed, f)
// 		case errChan <- err:
// 			return 0, []model.FileSummary{}, err
// 		case <-stopChan:
// 			return float64(len(filenames)-len(failed)) / float64(len(filenames)), failed, nil
// 		}
// 	}
// }
